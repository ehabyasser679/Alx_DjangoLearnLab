# Bookshelf App Security Documentation

This document outlines all security measures implemented in the bookshelf application.

## Table of Contents

1. [SQL Injection Prevention](#sql-injection-prevention)
2. [Input Validation and Sanitization](#input-validation-and-sanitization)
3. [Content Security Policy (CSP)](#content-security-policy-csp)
4. [CSRF Protection](#csrf-protection)
5. [XSS Prevention](#xss-prevention)
6. [Authentication and Authorization](#authentication-and-authorization)
7. [Security Headers](#security-headers)

## SQL Injection Prevention

### Django ORM Usage

**All database queries use Django ORM**, which automatically parameterizes all SQL queries, preventing SQL injection attacks.

#### Example: Safe Query Pattern

```python
# ✅ SECURE: Django ORM automatically parameterizes queries
books = book.objects.filter(title__icontains=search_query)

# ✅ SECURE: Using Q objects for complex queries
books = book.objects.filter(
    Q(title__icontains=search_query) | 
    Q(author__icontains=search_query)
)

# ✅ SECURE: get_object_or_404 uses parameterized queries
book_instance = get_object_or_404(book, pk=pk)
```

#### What NOT to Do

```python
# ❌ INSECURE: Never use raw SQL with string formatting
# This is vulnerable to SQL injection:
books = book.objects.raw(f"SELECT * FROM book WHERE title = '{user_input}'")

# ❌ INSECURE: Never concatenate user input into queries
query = "SELECT * FROM book WHERE title = '" + user_input + "'"
```

### Implementation Details

- **All views** use Django ORM methods (`filter()`, `get()`, `all()`, etc.)
- **No raw SQL queries** are used in the application
- **Parameterized queries** are automatically generated by Django ORM
- **Search functionality** uses ORM filters with proper escaping

## Input Validation and Sanitization

### Form Validation

The `BookForm` class implements comprehensive input validation:

```python
class BookForm(ModelForm):
    def clean_title(self):
        """Validate and sanitize title input"""
        title = self.cleaned_data.get('title')
        if title:
            title = title.strip()[:200]  # Limit length
            if not title:
                raise forms.ValidationError("Title cannot be empty.")
        return title
    
    def clean_author(self):
        """Validate and sanitize author input"""
        author = self.cleaned_data.get('author')
        if author:
            author = author.strip()[:100]  # Limit length
            if not author:
                raise forms.ValidationError("Author cannot be empty.")
        return author
    
    def clean_publication_year(self):
        """Validate publication year"""
        year = self.cleaned_data.get('publication_year')
        if year:
            # Ensure year is reasonable
            from datetime import datetime
            current_year = datetime.now().year
            if year < 1000 or year > current_year + 1:
                raise forms.ValidationError(
                    f"Publication year must be between 1000 and {current_year + 1}."
                )
        return year
```

### Search Input Validation

Search queries are validated in the `index` view:

```python
# Get and validate search query
search_query = request.GET.get('search', '').strip()

# Limit search length to prevent DoS attacks
if len(search_query) > 100:
    search_query = search_query[:100]

# Use Django ORM for safe querying
if search_query:
    books = book.objects.filter(
        Q(title__icontains=search_query) | 
        Q(author__icontains=search_query)
    )
```

### Security Benefits

- **Length limits** prevent buffer overflow and DoS attacks
- **Type validation** ensures data integrity
- **Whitespace stripping** prevents hidden character attacks
- **Range validation** prevents invalid data entry

## Content Security Policy (CSP)

### Implementation

CSP is implemented via custom middleware (`LibraryProject.middleware.CSPMiddleware`) that adds security headers to all responses.

### CSP Directives

Configured in `settings.py`:

```python
CSP_DEFAULT_SRC = "'self'"
CSP_SCRIPT_SRC = "'self' 'unsafe-inline'"
CSP_STYLE_SRC = "'self' 'unsafe-inline'"
CSP_IMG_SRC = "'self' data:"
CSP_FONT_SRC = "'self'"
CSP_CONNECT_SRC = "'self'"
CSP_FRAME_ANCESTORS = "'none'"
```

### Security Benefits

- **Prevents XSS attacks** by restricting script execution
- **Prevents data exfiltration** by controlling network requests
- **Prevents clickjacking** via `frame-ancestors: 'none'`
- **Defense in depth** alongside Django's built-in protections

### Production Considerations

In production, consider removing `'unsafe-inline'` from `CSP_SCRIPT_SRC` and `CSP_STYLE_SRC` if possible. This requires:
- Moving all inline scripts to external files
- Using nonces or hashes for required inline scripts

## CSRF Protection

### Implementation

- **CSRF middleware** enabled in `settings.py`
- **CSRF tokens** included in all forms via `{% csrf_token %}`
- **Automatic validation** on all POST requests

### Protected Forms

All forms in bookshelf templates include CSRF tokens:
- `book_form.html` - Create/Edit forms
- `book_confirm_delete.html` - Delete confirmation

### Security Benefits

- **Prevents CSRF attacks** by validating request origin
- **Session-based tokens** tied to user sessions
- **Automatic validation** via Django middleware

## XSS Prevention

### Template Auto-Escaping

Django templates automatically escape all variables:

```html
<!-- ✅ SECURE: Automatically escaped -->
<p>{{ book.title }}</p>

<!-- ✅ SECURE: Explicit escaping (defense in depth) -->
<p>{{ book.title|escape }}</p>
```

### Search Input Escaping

Search queries are escaped in templates:

```html
<input type="text" name="search" 
       value="{{ search_query|escape }}" 
       maxlength="100">
```

### Security Benefits

- **Automatic escaping** prevents XSS in most cases
- **Explicit escaping** provides defense in depth
- **CSP headers** provide additional XSS protection

## Authentication and Authorization

### Permission-Based Access Control

All views require authentication and specific permissions:

```python
@login_required
@permission_required('bookshelf.can_view_book', raise_exception=True)
def index(request):
    # View implementation
```

### Permission Checks

- **`@login_required`**: Ensures user is authenticated
- **`@permission_required`**: Checks specific permission
- **`raise_exception=True`**: Returns 403 instead of redirecting

### Security Benefits

- **Prevents unauthorized access** to protected views
- **Granular permissions** for different operations
- **Clear error messages** (403 Forbidden) for unauthorized attempts

## Security Headers

### Configured Headers

In `settings.py`:

```python
# XSS Protection
SECURE_BROWSER_XSS_FILTER = True

# Clickjacking Protection
X_FRAME_OPTIONS = 'DENY'

# MIME Type Sniffing Protection
SECURE_CONTENT_TYPE_NOSNIFF = True

# Cookie Security (set to True in production with HTTPS)
CSRF_COOKIE_SECURE = False  # Development
SESSION_COOKIE_SECURE = False  # Development
```

### Security Benefits

- **XSS Filter**: Browser-level XSS protection
- **Frame Options**: Prevents clickjacking attacks
- **Content Type**: Prevents MIME type confusion attacks
- **Secure Cookies**: Prevents cookie theft over HTTP (requires HTTPS)

## Best Practices

### 1. Always Use Django ORM

✅ **DO**: Use Django ORM for all database queries
```python
books = book.objects.filter(title__icontains=search)
```

❌ **DON'T**: Use raw SQL with string formatting
```python
books = book.objects.raw(f"SELECT * FROM book WHERE title = '{input}'")
```

### 2. Validate All Input

✅ **DO**: Use Django forms with validation
```python
form = BookForm(request.POST)
if form.is_valid():
    form.save()
```

❌ **DON'T**: Trust user input without validation
```python
book.title = request.POST['title']  # No validation!
```

### 3. Escape Output

✅ **DO**: Let Django templates auto-escape
```html
<p>{{ book.title }}</p>
```

❌ **DON'T**: Use `|safe` filter with untrusted data
```html
<p>{{ user_input|safe }}</p>  # Dangerous!
```

### 4. Use HTTPS in Production

✅ **DO**: Enable secure cookies in production
```python
CSRF_COOKIE_SECURE = True
SESSION_COOKIE_SECURE = True
```

### 5. Limit Input Length

✅ **DO**: Validate and limit input length
```python
if len(search_query) > 100:
    search_query = search_query[:100]
```

## Security Testing

See [SECURITY_TESTING.md](SECURITY_TESTING.md) for detailed testing procedures.

## Summary

The bookshelf app implements multiple layers of security:

1. **SQL Injection Prevention**: Django ORM with parameterized queries
2. **Input Validation**: Comprehensive form validation and sanitization
3. **CSP**: Content Security Policy headers
4. **CSRF Protection**: Tokens in all forms
5. **XSS Prevention**: Template auto-escaping
6. **Authorization**: Permission-based access control
7. **Security Headers**: Multiple HTTP security headers

These measures work together to provide defense in depth against common web application vulnerabilities.

